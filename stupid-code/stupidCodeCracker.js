/*
 * A ten-digit keypad lock requires a 4-digit code. You want to brute force
 * the code. The catch, however, is that the lock remembers the last three
 * digits, so if you've already entered 4 digits, it will treat the 5th
 * as the last digit in a new code.
 *
 * Devise an algorithm to create the shortest string possible that can 
 * crack the code. Runtime complexity is not important, as the crackers
 * will precompute the key.
 */

/*
 * There are exactly 10,000 codes: 4 digits, 10 possibilities each. The naive
 * solution is 40,000 characters long. 

 *perm length
 * 1	4
 * 2	5
 * 3	6
 * 4	7
 * 10k 10,003
 *
 * shortest length = number of coodes + number rememebered
 */

const KEYPAD_DIGITS = 10;
const CODE_LENGTH = 4;
const POSSIBLE_CODES = Math.pow(KEYPAD_DIGITS, CODE_LENGTH);
const REMEMBERED = 3;
const MIN_CODE_LENGTH = 3 + POSSIBLE_CODES;

function crack () {
	var prefix = [0];

	while (prefix.length > 0) {

		if (prefix.length === MIN_CODE_LENGTH) {
			var candidate = prefix.join(''); // create candidate solution
	//		console.log('candidate soln', candidate.slice(candidate.length - 4, candidate.length));

			if (isValid(candidate)) 
				return candidate;
			else
				update(prefix); // update the candidate to a new prefix
		}
		else {
			// prefix isn't long enough to be a candidate
			// add new digits on the end
			prefix.push(0);
		}
	}

	return false;
}

function update (c) {
	// increment the last digit
	// if it's a 10, we've checked all digits in that position
	// with that prefix, so remove it
	// do this "recursively" until we're at a prefix that we have not seen
	while (++c[c.length - 1] >= 10) {
		c.pop();
	}
	if (c[c.length - 1] === 0) {
		console.log('moving to', c[0]);
	}
}


function next () {
	/*
	 * Deterministically generate all possible digit combos in 10,003 digits
	 *
	 * 10 ^ 10,003
	 *
	 * add digit to string
	 * if string is length 10,003, test it
	 * otherwise, add a digit to the string
	 * if string is length 10,003, test it
	 * otherwise, add a digit to the string.
	 *
	 * if it's not valid, remove the last digit and increment it
	 * if the digit has been incremented to 10, pop and increment previous
	 * if that has been incrmented to 10, pop and increment previous
	 *
	 * if string is length 10,003
	 *		test its validity
	 *		if valid
	 *			return
	 *		else
	 *			increment last digit
	 *			if last digit = 10
	 *				pop it
	 *				increment last digit
	 *				if last digit = 10
	 *					pop it
	 *					increment last digit
	 * else
	 *		push(0)
	 *		
	 */
	
	
}

function naiveCrack () {
	var codes = [];

	for (var i = 0; i < 10; i++) {
		for (var j = 0; j < 10; j++) {
			for (var k = 0; k < 10; k++) {
				for (var l = 0; l < 10; l++) {
					codes.push(i.toString() + j + k + l);
				}
			}
		}
	}

	return codes.join('');
}

/**
 * Verify a candidate solution
 * @param c - candidate solution
 * @return true if c is a valid solution
 */
function isValid (c) {
	var generatedCodes = []; // list of all codes generated by c

	// check all 4-digit subsequences
	// need <= b/c using slice, which excludes last char
	for (var start = 0, end = 4; end <= c.length; start++, end++) {
		var code = c.slice(start, end);
		if (generatedCodes[code]) {
			return false; // break early if we've already seen code?
		}
		else {
			generatedCodes[code] = true;
		}
	}

	// returns false if there are any undefined elements
	return generatedCodes.every(function exists (code) { return code; });
}

module.exports = {
	naiveCrack: naiveCrack,
	crack: crack
}
